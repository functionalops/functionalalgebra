---
title: Axiomatic Software
summary: How could we go about building software systematically using axioms as the foundation and building up layer by layer?
---

<h3>Axiomatic Systems: Axioms, Terms, &amp; Theorems</h3>

<p>
Join me while we take a peak at a world that makes sense, craves
consistency, makes order out of mayhem, and follows logical deduction
to its extreme. Yes, welcome to the world of mathematics. Fear not, I will
be your guide and will steer you away from the mind bending fields that
some of these peculiar creatures (mathematicians) graze in.
</p>

<h4>Definitions</h4>

<p>
An <strong>axiom</strong> is a basic <em>truth</em> that, in combination with
other axioms, form the foundation bed of reasoning about a whole
system. I use the word <em>system</em> here to mean a mental model.
Axioms are the only parts of the system that do not need to be
<i>proved</i>. Everything else in an axiomatic system, which are built on
top of the initial set of axioms must be proved at each step.
</p>

<blockquote>
  <q>
  Axioms (sometimes called postulates) are logical statements that are
  assumed to be true and do not need to be proved.
  </q>
</blockquote>

<p>
Axioms typically involve <strong>terms</strong>, often <em>undefined</em>
terms to avoid cyclic definitions. A term whether defined or undefined can
be either an <em>element</em> or a <em>relation</em>. An element being
a thing (or object) and a relation referring to a relationship between two
elements.
</p>

<p>
Theorems are logical deductions based on the axioms of the system and other
already derived theorems of the same system. <em>Theorems</em> must always
be proved. Note: how I gloss over what proof means here :)
</p>

<p>
A desirable property of an axiomatic system is consistency which is defined
to mean there are no contradictions in the whole system (axioms and
theorems). For instance, a statement and its negation cannot both be true.
</p>

<h4>Examples</h4>

<p>
If you have made it this far, congratulations, that was a lot of
definitions. Now I want to show you a couple of examples to integrate
your understanding on the topic further.
</p>

<p>

</p>

<h3>Enter the <em>Real</em> World</h3>

<p>
Now that is just mathematics. We live in the <em>real</em> world and
software doesn't execute in a perfect world. It must be built by humans for
an application domain that runs on hardware that all exist in the
<em>real</em> world with imperfections and no obvious way to <em>prove</em>
propositions.
</p>

<p>
So how can we reason about software as if we were basing it on an axiomatic
foundation? And perhaps more importantly why would we want to?
</p>

<p>
Let us tackle the second question first.
</p>
